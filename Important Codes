COMBINATIONAL CODES 

// 1. Full Adder - Dataflow Style
module full_adder_dataflow (
    input a, b, cin,
    output sum, cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (a & cin);
endmodule

// 2. Full Adder - Structural Style
module full_adder_structural (
    input a, b, cin,
    output sum, cout
);
    wire w1, w2, w3;
    xor (w1, a, b);
    xor (sum, w1, cin);
    and (w2, a, b);
    and (w3, w1, cin);
    or (cout, w2, w3);
endmodule

// 3. Full Adder - Using Two Half Adders (Structural Style)
module half_adder (
    input a, b,
    output sum, carry
);
    xor (sum, a, b);
    and (carry, a, b);
endmodule

module full_adder_two_half_adders (
    input a, b, cin,
    output sum, cout
);
    wire sum1, carry1, carry2;
    half_adder ha1 (.a(a), .b(b), .sum(sum1), .carry(carry1));
    half_adder ha2 (.a(sum1), .b(cin), .sum(sum), .carry(carry2));
    or (cout, carry1, carry2);
endmodule

// 4. Logic Gates (All Gates)
module logic_gates (
    input a, b,
    output and_out, or_out, not_out, nand_out, nor_out, xor_out, xnor_out
);
    assign and_out = a & b;
    assign or_out = a | b;
    assign not_out = ~a;
    assign nand_out = ~(a & b);
    assign nor_out = ~(a | b);
    assign xor_out = a ^ b;
    assign xnor_out = a ~^ b;
endmodule

// 5. 4:1 Mux - Dataflow Style
module mux_4to1_dataflow (
    input [3:0] d, input [1:0] sel,
    output y
);
    assign y = (sel == 2'b00) ? d[0] :
               (sel == 2'b01) ? d[1] :
               (sel == 2'b10) ? d[2] : d[3];
endmodule

// 6. 4:1 Mux using 2:1 Mux (Structural Style)
module mux_2to1 (
    input a, b, sel,
    output y
);
    assign y = sel ? b : a;
endmodule

module mux_4to1_structural (
    input [3:0] d, input [1:0] sel,
    output y
);
    wire w1, w2;
    mux_2to1 m1 (.a(d[0]), .b(d[1]), .sel(sel[0]), .y(w1));
    mux_2to1 m2 (.a(d[2]), .b(d[3]), .sel(sel[0]), .y(w2));
    mux_2to1 m3 (.a(w1), .b(w2), .sel(sel[1]), .y(y));
endmodule

// 7. 4:1 Mux Using Two-Level Logic (Structural Style)
module mux_4to1_two_level (
    input [3:0] d, input [1:0] sel,
    output y
);
    wire w0, w1, w2, w3;
    and (w0, ~sel[1], ~sel[0], d[0]);
    and (w1, ~sel[1], sel[0], d[1]);
    and (w2, sel[1], ~sel[0], d[2]);
    and (w3, sel[1], sel[0], d[3]);
    or (y, w0, w1, w2, w3);
endmodule

// 8. 2 Bits Wide 4:1 Mux - Dataflow Style
module mux_4to1_2bit (
    input [1:0] d0, d1, d2, d3, input [1:0] sel,
    output [1:0] y
);
    assign y = (sel == 2'b00) ? d0 :
               (sel == 2'b01) ? d1 :
               (sel == 2'b10) ? d2 : d3;
endmodule

// 9. Binary to Gray Code Converter
module binary_to_gray (
    input [3:0] binary,
    output [3:0] gray
);
    assign gray[3] = binary[3];
    assign gray[2] = binary[3] ^ binary[2];
    assign gray[1] = binary[2] ^ binary[1];
    assign gray[0] = binary[1] ^ binary[0];
endmodule

// 10. Gray to Binary Code Converter
module gray_to_binary (
    input [3:0] gray,
    output [3:0] binary
);
    assign binary[3] = gray[3];
    assign binary[2] = binary[3] ^ gray[2];
    assign binary[1] = binary[2] ^ gray[1];
    assign binary[0] = binary[1] ^ gray[0];
endmodule
// 11. Binary to Excess-3 Code Converter
module binary_to_excess3 (
    input [3:0] binary,
    output [3:0] excess3
);
    assign excess3 = binary + 4'b0011;
endmodule

// 12. 4-bit Ripple Carry Adder
module ripple_carry_adder (
    input [3:0] a, b,
    input cin,
    output [3:0] sum,
    output cout
);
    wire c1, c2, c3;
    full_adder_dataflow fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));
    full_adder_dataflow fa1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));
    full_adder_dataflow fa2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));
    full_adder_dataflow fa3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(cout));
endmodule

// 13. 4 to 2 Priority Encoder
module priority_encoder_4to2 (
    input [3:0] in,
    output [1:0] out,
    output valid
);
    assign valid = |in; // Valid is high if any input is high
    assign out = (in[3]) ? 2'b11 :
                 (in[2]) ? 2'b10 :
                 (in[1]) ? 2'b01 : 2'b00;
endmodule

// 14. 8 to 3 Priority Encoder with a Valid Bit
module priority_encoder_8to3 (
    input [7:0] in,
    output [2:0] out,
    output valid
);
    assign valid = |in; // Valid is high if any input is high
    assign out = (in[7]) ? 3'b111 :
                 (in[6]) ? 3'b110 :
                 (in[5]) ? 3'b101 :
                 (in[4]) ? 3'b100 :
                 (in[3]) ? 3'b011 :
                 (in[2]) ? 3'b010 :
                 (in[1]) ? 3'b001 : 3'b000;
endmodule

// 15. 3 to 8 Decoder
module decoder_3to8 (
    input [2:0] in,
    output [7:0] out
);
    assign out = 1 << in;
endmodule

// 16. 2 to 4 Decoder
module decoder_2to4 (
    input [1:0] in,
    output [3:0] out
);
    assign out = 1 << in;
endmodule


// 18. Full Adder using 4:1 Mux
module full_adder_using_mux (
    input a, b, cin,
    output sum, cout
);
    wire [3:0] sum_mux_data = {1'b1, 1'b0, 1'b0, 1'b1};
    wire [3:0] cout_mux_data = {1'b1, 1'b1, 1'b0, 1'b0};
    assign sum = sum_mux_data[{a, b}];
    assign cout = cout_mux_data[{a, b}];
endmodule

